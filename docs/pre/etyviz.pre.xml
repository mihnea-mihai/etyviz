<?xml version="1.0" encoding="UTF-8"?><database name="etyviz" schema="pre" type="PostgreSQL - 16.2 (Ubuntu 16.2-1.pgdg22.04+1)">
   <tables>
      <table name="dump" numRows="0" remarks="Derived from `raw_dump` by parsing the relevant JSON paths." schema="pre" type="VIEW" viewSql=" SELECT line_no,&#10;    (jdoc -&gt;&gt; 'word'::text) AS word,&#10;    (jdoc -&gt;&gt; 'lang_code'::text) AS lang_code,&#10;    (jdoc -&gt;&gt; 'lang'::text) AS lang_name,&#10;    ((jdoc -&gt;&gt; 'etymology_number'::text))::smallint AS etym_no,&#10;    (jdoc -&gt;&gt; 'pos'::text) AS pos,&#10;    (jsonb_path_query_first(jdoc, '$.&quot;forms&quot;[*]?(@.&quot;tags&quot;[0] == &quot;romanization&quot;).&quot;form&quot;'::jsonpath) #&gt;&gt; '{}'::text[]) AS translit,&#10;    (jdoc #&gt;&gt; ARRAY['senses'::text, '0'::text, 'glosses'::text, '0'::text]) AS gloss,&#10;    (jdoc #&gt;&gt; ARRAY['senses'::text, '0'::text, 'form_of'::text, '0'::text, 'word'::text]) AS form_of,&#10;    (jdoc -&gt;&gt; 'title'::text) AS title,&#10;    (jdoc -&gt;&gt; 'redirect'::text) AS redirect,&#10;    (jdoc -&gt; 'etymology_templates'::text) AS etymology_templates&#10;   FROM pre.raw_dump;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="line_no" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="line_no" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="pre" table="raw_dump"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="word" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="lang_code" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="lang_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="etym_no" nullable="true" remarks="" size="5" type="int2" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="pos" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="translit" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="gloss" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="form_of" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="title" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="redirect" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="etymology_templates" nullable="true" remarks="" size="2147483647" type="jsonb" typeCode="1111"/>
      </table>
      <table name="raw_dump" numRows="9493787" remarks="This table holds the full wiktextract dump, in raw format.&#10;    Each entry is a line containing the full JSON object.&#10;    It is initially populated by a script parsing the dump file." schema="pre" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="line_no" nullable="false" remarks="Line number of the entry in the wiktextract file.&#10;    This is later used as the unique ID of the extracted word." size="10" type="int4" typeCode="4">
            <child column="node_id" foreignKey="node_node_id_fkey" implied="false" onDeleteCascade="false" schema="core" table="node"/>
            <child column="line_no" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="pre" table="dump"/>
            <child column="line_no" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="pre" table="raw_links"/>
            <child column="line_no" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="pre" table="templates"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="jdoc" nullable="false" remarks="Full JSON object of the entry.&#10;    Is used to fill the other tables from the raw data." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="line_no" sequenceNumberInPK="1"/>
         <index name="wiktextract_pkey" unique="true">
            <column ascending="true" name="line_no"/>
         </index>
      </table>
      <table name="raw_links" numRows="0" remarks="Holds all tentative links from an entry (with ID as `line_no`)&#10;to candidate other entries (defined by `word` and `lang_code`)." schema="pre" type="VIEW" viewSql=" WITH arguments_lang AS (&#10;         SELECT templates.line_no,&#10;            templates.template_name,&#10;            templates.args,&#10;            (templates.args -&gt;&gt; (link_data.lang_idx)::text) AS lang_code,&#10;            link_data.word_idxs&#10;           FROM (pre.templates&#10;             JOIN core.link_data ON ((templates.template_name = (link_data.link_type)::text)))&#10;        ), expanded_arguments AS (&#10;         SELECT arguments_lang.line_no,&#10;            arguments_lang.template_name,&#10;            (jsonb_each_text(arguments_lang.args)).key AS key,&#10;            (jsonb_each_text(arguments_lang.args)).value AS value,&#10;            arguments_lang.lang_code,&#10;            arguments_lang.word_idxs&#10;           FROM arguments_lang&#10;        )&#10; SELECT line_no,&#10;    template_name,&#10;    lang_code AS target_lang,&#10;    value AS target_word&#10;   FROM expanded_arguments&#10;  WHERE (key = ANY ((word_idxs)::text[]));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="line_no" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="line_no" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="pre" table="raw_dump"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="template_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="target_lang" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="target_word" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
      </table>
      <table name="templates" numRows="0" remarks="Each row is an element of the `etymology_template` node." schema="pre" type="VIEW" viewSql=" WITH raw_templates AS (&#10;         SELECT dump.line_no,&#10;            jsonb_array_elements(dump.etymology_templates) AS templates&#10;           FROM pre.dump&#10;        )&#10; SELECT line_no,&#10;    (templates -&gt;&gt; 'name'::text) AS template_name,&#10;    (templates -&gt; 'args'::text) AS args&#10;   FROM raw_templates;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="line_no" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="line_no" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="pre" table="raw_dump"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="template_name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="args" nullable="true" remarks="" size="2147483647" type="jsonb" typeCode="1111"/>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="false" name="edge_insert_simple()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Populates the `edge` table with information extracted from `pre.raw_links`.
Only takes into account entries not needing disambiguation.]]></comment>
         <definition language="sql"><![CDATA[INSERT INTO core.edge (
    source_id, link_type, target_id
)
    SELECT line_no, template_name, target_node.node_id
    FROM pre.raw_links
    JOIN core.node AS source_node
    ON source_node.node_id = raw_links.line_no
    JOIN core.node AS target_node
    ON target_node.word = raw_links.target_word
        AND target_node.lang_code = raw_links.target_lang
        AND target_node.etym_no IS NULL
ON CONFLICT DO NOTHING;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lang_count_insert()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Populates `entry_count` column in the `lang` table,
    grouping by `lang_code`.]]></comment>
         <definition language="sql"><![CDATA[WITH lang_counts AS (
    SELECT count(*), lang_code
    FROM pre.dump
    WHERE lang_code IS NOT NULL
    GROUP BY lang_code
)
UPDATE core.lang
SET entry_count = count
FROM lang_counts
WHERE lang.lang_code = lang_counts.lang_code;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lang_insert()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Populates `lang_code` and `lang_name` columns in the `lang` table.
    If multiple language names are found for the same language code,
    the most used is saved in the table.]]></comment>
         <definition language="sql"><![CDATA[WITH lang_stats AS (
    SELECT lang_code, lang_name, count(*)
    FROM pre.dump
    WHERE lang_code IS NOT NULL
    GROUP BY lang_code, lang_name
    ORDER BY count(*) DESC
)
INSERT INTO core.lang (
    lang_code, lang_name
)
SELECT lang_code, lang_name
FROM lang_stats
ON CONFLICT DO NOTHING;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="node_insert()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Populates the `node` table with information extracted from the dump.]]></comment>
         <definition language="sql"><![CDATA[INSERT INTO core.node (
    node_id, word, lang_code, etym_no, pos, translit, gloss
)
SELECT line_no, word, lang_code, etym_no, pos, translit, gloss
FROM pre.dump
WHERE word IS NOT NULL
ON CONFLICT DO NOTHING;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
   </routines>
</database>
